## 💡 아이템 11: 가독성을 목표로 설계하라

> “개발자가 코드를 작성하는데는 1분 걸리지만, 이를 읽는데는 10분이 걸린다”
> - Robert C. Martin (클린코드)

즉, 개발자는 어떤 코드를 작성하는 것보다 읽는 데 많은 시간을 소모한다는 것이다.
실제로 프로젝트를 진행할 때도 코드 한 줄 고치겠다고, 몇 주 동안 코드를 살펴보는 상황도 많다.
프로그래밍은 쓰기보다 읽기가 중요하다는 의미이다.
따라서 항상 가독성을 생각하면서 코드를 작성해야 한다.

### 📌 인식 부하 감소

사실 가독성은 사람에 따라 다르게 느낄 수 있다.
하지만 일반적으로 많은 사람의 '경험'과 '인식에 대한 과학'으로 만들어진 어느 정도의 규칙이 있다.
일단 다음 두 코드를 살펴보자

```kotlin
// 구현 A
if (person != null && person.isAdult) {
    view.showPerson(person)
} else {
    view.showError()
}

// 구현 B
person?.takeIf { it.isAdult }
    ?.let(view::showPerson)
    ?: view.showError()
```

가독성이란 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미한다.
이는 우리의 뇌가 얼마나 많은 관용구(구조, 함수, 패턴)에 익숙해져 있는지에 따라서 다르다.
코틀린 초보자에게는 구현 A가 더 읽고 이해하기 쉽다.
일반적은 관용구(if/else, &&, 메서드 호출)를 사용하고 있기 때문이다.
구현 B는 코틀린에서는 일반적으로 사용되는 관용구(안전 호출 ?., takeIf, let, Elvis 연산자, 제한된 함수 레퍼런스 view::showPerson)를 사용하고 있다.
코틀린에서 일반적으로 사용되는 관용구이므로, 경험이 많은 코틀린 개발자라면 그래도 모드를 쉽게 읽을 수 있을 것이다.
하지만 숙련된 개발자만을 위한 코드는 좋은 코드가 아니다.
구현 A와 구현 B는 사실 비교조차 할 수 없을정더로 A가 훨씬 가독성이 좋은 코드이다.

또한 구현 A는 수정하기 슆다.
if 블록에 작업을 추가해야 한다고 생각해 보자.
쉽게 추가할 수 있을 것이다.
구현 B는 어떻게 수정해야 할까?
일단 더 이상 함수 참조를 사용할 수 없으므로, 코드를 수정해야 한다.
그리고 else 블록 쪽을 수정하는 일은 좀 어렵다.
Elvis 연산자의 오른쪽 부분이 하나 이상의 표현식을 갖게 하려면, 함수를 추가로 사용해야 한다.

```kotlin
// 구현 A
if (person != null && person.isAdult) {
    view.showPerson(person)
    view.hideProgressWithSuccess()
} else {
    view.showError()
    view.hideProgress()
}

// 구현 B
person?.takeIf { it.isAdult }
    ?.let {
        view.showPerson(it)
        view.hideProgressWithSuccess()
    } ?: run {
    view.showError()
    view.hideProgress()
}
```

구현 A는 디버깅도 더 간단하다.
일반적으로 디버깅 도구조차 이러한 기본 구조를 더 잘 분석해 주기 때문이다.

이처럼 일반적이지 않고 '굉장히 창의적인' 구조는 유연하지 않고, 지원도 제대로 받지 못한다.

근데 참고로 구현 A와 구현 B는 실행 결과가 다르다.
let은 람다식의 결과를 리턴한다.
즉, showPerson이 null을 리턴하면, 두번째 구현 때는 showError도 호출한다.
익숙하지 않은 구조를 사용하면, 이처럼 잘못된 동작을 코드를 보면서 확인하기 어렵다.

정리하면, 기본적으로 '인지 부하'를 줄이는 방향으로 코드를 작성하자.
우리의 뇌는 패턴을 인식하고, 패턴을 기반으로 프로그램의 작동 방식을 이해한다.
가독성은 '뇌가 프로그램의 작동 방식을 이해하는 과정'을 더 짧게 만드는 것이다.
자주 사용되는 패턴을 활용하면, 이와 같은 과정을 더 짧게 만들 수 있다.
뇌는 기본적으로 짧은 코드를 빠르게 읽을 수 있겠지만, 익숙한 코드는 더 빠르게 읽을 수 있다.

### 📌 극단적이 되지 않기

방금 let으로 인해서 예상하지 못한 결과가 나올 수 있다고 했다.
이 이야기를 'let은 절대로 쓰면 안 된다.'로 이해하는 사람들이 꽤 많다.
극단적이 되지 말기를 바란다.
let은 좋은 코드를 만들기 위해서 다양하게 활용되는 ㄴ인기 있는 관용구이다.
예를 들어 nullable 가변 프로퍼티가 있고, null이 아닐 때만 어떤 작업을 수행해야 하는 경우가 있다고 하자.
가변 프로퍼티는 쓰레드와 관련된 문제를 발생시킬 수 있으므로, 스마트 캐스팅이 불가능하다.
여러 가지 해결 방법이 있는데, 일반적으로 다음과 같이 안전 호출 let을 사용하자.

```kotlin
class Person(val name: String)

var person: Person? = null

// person != null 일 때만 실행하고 싶은 코드가 있는경우
fun printName() {
    person?.let {
        print(it.name)
    }
}
```

이런 관용구는 널리 사용되며, 많은 사람이 쉽게 인식한다.
이외에도 다음과 같은 경우에 let을 많이 사용한다.

- 연산을 아규먼트 처리 후로 이동시킬 때
- 데코레이터를 사용해서 객체를 랩할 때

```kotlin
    students
    .filter { it.result >= 50 }
    .joinToString(separator = "\n") {
        "${it.name} ${it.surname}, ${it.result}"
    }
    .let(::print) // print 를 뒤로 이동시킨 경우

var obj = FileInputStream("/file.gz")
    .let(::BufferedInputStream)
    .let(::ZipInputStream)
    .let(::ObjectInputStream)
    .readObject() as SomeObject
```

이 코드들은 디버그하기 어렵고, 경험이 적은 코틀린 개발자는 이해하기 어렵다.
따라서 비용이 발생한다.
하지만 이 비용은 지불할 만한 가치가 있으므로 사용해도 괜찮다.
문제가 되는 경우는 비용을 지불할 만한 가치가 없는 코드에 비용을 지불하는 경우(정당한 이유 없이 복잡성을 추가할 때)이다.

물론 어떤 것이 비용을 지불할 만한 코드인지 아닌진는 항상 논란이 있을 수 있다.
균형을 맞추는 것이 중요하다.
일단 어떤 구조들이 어떤 복잡성을 가져오는지 등을 파악하는 것이 좋다.
또한 두 구조를 조합해서 사용하면, 단순하게 개별적인 복잡성의 합보다 훨씬 커진다는 것을 기억하자

### 📌 컨벤션

사람에 따라서 가독성에 대한 관점이 다르다는 것을 알아보았다.
많은 개발에서 함수 이름을 어떻게 지어야 하는지, 어떤 것이 명시적이어야 하는지, 어떤 것이 암묵적이어야 하는지, 어떤 관용구를 사용해야 하는지 등으로 토론하자.
프로그래밍은 표현력의 예술이다.
이를 위해 이해하고 기억해야 하는 몇 가지 규칙이 있다.

필자가 생각하는 코틀린으로 할 수 있는 최악의 코드는 다음과 같다.

```kotlin
val abc = "A" { "B" } and "C"
print(abc) // ABC
```

이 코드가 가능하게 하려면, 다음과 같은 코드가 있어야 한다.

```kotlin
operator fun String.invoke(f: () -> String): String = this + f()

infix fun String.and(s: String) = this + s
```

이 코드는 이후에 설명하는 수많은 규칙들을 위반한다.

- 연산자는 의미에 맞게 사용해야한다. invoke는 이러한 형태로 사용하면 안 된다.
- '람다를 마지막 아규먼트로 사용한다'라는 컨벤션을 여기에 적용하면, 코드가 복잡해진다. invoke 연산자와 함께 이러한 컨벤션을 적용하는 것은 신중해야 한다.
- 현재 코드에서 and라는 함수 이름이 실제 함수 내부에서 이루어지는 처리와 맞지 않는다.
- 문자열을 결합하는 기능은 이미 언엉에 내장되어 있다. 이미 있는 것을 다시 만들 필요는 없다.



