# 6장 채널 - 통신을 통한 메모리 공유

## 채널의 이해

채널은 동시성 코드 간에 서로 안전한 통신을 할 수 있도록 해주는 도구다.
채널은 동시성 코드가 메시지를 보내 통신할 수 있도록 해준다.
채널은 실행 중인 스레드에 상관없이 서로 다른 코루틴 간에 메시지를 안전하게 보내고 받기 위한 파이프라인으로 생각 할 수 있다.

### 스트리밍 데이터 사례

최근에 특정 키워드에 대해 10개의 콘텐츠 인덱서를 조회한 뒤 검색 결과를 보여주는 비교적 간단한 프로그래밍 작업을 하게 됐다.
첫 번째 접근 방법은 각 콘텐츠 인덱서를 위한 코루틴을 시작해서 Deferred<List<ResultDto>>를 반환하고, 모든 코루틴이 완료되면 결과를 병합해서 UI에 보내는 것이다.

각 인덱서가 응답을 반환하는 시간이 다르고 일부는 상당히 오래 걸릴 수 있다는 문제점이 있다.
그렇기 때문에 모든 코루틴이 완료될 때까지 기다려야 하는데, 결과 표시를 지연시켜서 사용자가 즉시 결과와 상호작용하는 것을 방해한다.

더 좋은 해결책을 위해 몇 가지 변화가 필요하다.
첫 번째는 ReceiveChannel<ResultDto>를 반환하는 것으로, 결과가 수신되는 즉시 UI로 보낼 수 있다.
둘째는 결과가 도착하는 대로 코루틴으로부터 끊김 없이 결과를 수신할 수 있도록 하는 방법이다.

이를 위해 각 코루틴은 응답을 가져오고 처리할 때 단일 채널을 통해서 결과를 전송한다.

### 분산 작업 사례

애플리케이션의 목적은 모든 커넥션을 사용해서 가능한 많은 아티클을 가져오고 파싱한 후 카테고리를 분류해서 처리된 정보를 데이터베이스에 저장하는 것이다.
접근 방법은 가능한 모든 커텍션에 하나의 코루틴을 사용해 각 아티클을 가져와서 파싱하고, 콘텐츠를 분류한 다음 데이터베이스에 넣는 것이다.
각 코루틴은 하나를 끝내면 다음 아티클로 넘어갈 수 있다.

가용 가능한 커텍션을 최대로 사용하지 못한다는 문제점이 있는데, 가능한 것보다 더 낮은 속도로 인덱싱을 하고 있다는 것을 의미한다.
아티클을 가져오는 데 평균 30밀리초, 내용을 파싱하는 데 20초, 카탈로그를 만드는 데 30초가 소요되며, 이를 데이터베이스에 저장하는 데 20초가 걸린다고 가정하자.

아티클을 인덱스하는 데 걸리는 시간의 30%만이 가져오는 데 쓰이고, 나머지 70%는 처리하는 데 가용된다. 그럼에도 불구하고 인덱스 생성의 모든 단계를 수행하기 위해 하나의 코루틴을 사용하기 때문에, 각각의
아티클당 70 밀리초 동안 커넥션을 사용하지 않는다.

이보다 더 좋은 방법은 아티클을 가져오는 데만 사용되는 40개의 코루틴과 처리를 위한 또 다른 코루틴 그룹을 갖는 것이다.
두 그룹을 적절히 구성하면 이런 부하를 처리하기에 충분한 하드웨어가 있다는 가정 하에, 인덱스를 생성하는 전체 실행 시간 내내 커넥션 사용을 극대화할 수 있어 3배 이상 빠르게 컨텐츠를 인덱싱할 수 있다.
끊임없이 데이터를 가져오는 동시에 가능한 한 많이 처리하도록 하드웨어의 사용을 극대화할 수 있다.

```
나 🗣️

내용이 어려워서 요약하면 다음과 같다.

현재 애플리케이션은 모든 커넥션을 효율적으로 사용하지 못하고 있다.
아티클을 가져오는 데는 30ms가 걸리지만, 이후 파싱(20s), 분류(30s), 저장(20s) 단계에서도 같은 코루틴이 계속 쓰이기 때문이다.
이로 인해 전체 인덱싱 시간 중 70% 동안 커넥션이 놀고 있는 상태다.

해결 방법으로는, 아티클 가져오는 전용 코루틴(40개) 과 파싱 및 저장을 처리하는 별도의 코루틴 그룹으로 역할을 분리하는 것이다.
이렇게 하면 가져오기와 처리를 병렬로 수행하여 하드웨어 자원을 극대화하고, 전체 인덱싱 속도를 3배 이상 개선할 수 있다.

```

구현하려면 40개의 아티클 리트리버 그룹과 80개의 아티클 프로세서 그룹 사이에 채널만 추가하면 된다.
채널은 모든 리트리버가 가공되지 않은 원시 아티클을 가져와서 넣는 파이프라인을 작동하고, 프로세서는 가져온 아티클이 가용할 때마다 처리하고 저장하는 것이다.

## 채널 유형과 배압

Channel의 send()는 일시 중단 함수다.
그 이유는 실제로 데이터를 수신하는 누군가가 있을 때까지 전송하는 코드를 일시 중지하고 싶을 수도 있기 때문이다.

배압을 구성하기 위해 채널에 대한 버퍼를 정의할 수 있다.
채널을 통해 데이터를 보내는 코루틴은 채널 안의 요소가 버퍼 크기에 도달하면 일시 중단된다.
채널에서 요소가 제거되는 즉시, 송신자는 다시 재개된다.

### 언버퍼드 채널

버퍼가 없는 채널을 언버퍼드 채널이라고 한다.

#### RendezvousChannel

헌지 언버퍼드 채널의 유일한 구현은 RendezvousChannel뿐이다.
채널 구현은 버퍼가 전혀 없어서 그 채널에서 send()를 호출하면 리시버가 receive()를 호출할 때까지 일시 중지된다.

### 버퍼드 채널

두 번째 유형의 채널은 버퍼를 가지는 채널이다.
앞에서 언급한 바와 같이, 이 유형의 채널은 채널 내 요소의 수가 버퍼의 크기와 같을 때마다 송신자의 실행을 중지한다.
버퍼의 크기에 따라 몇 가지 종류의 버퍼드 채널이 있다.

#### LinkedListChannel

중단 없이 무한의 요소를 전송할 수 있는 채널을 원한다면 LinkedListChannel이 필요하다.
이 채널 유형은 어떤 송신자도 중단하지 않는다.

#### ArrayChannel

이 채널 유형은 버퍼 크기를 0부터 최대 int.MAX_VALUE - 1까지 가지며, 가지고 잇는 요소의 양이 버퍼 크기에 이르면 송신자를 일시 중단한다.

#### ConflatedChannel

세 번째 유형의 버퍼드 채널은 내보낸 요소가 유실돼도 괜찮다는 생각이 깔려 있다.
이 유형의 채녈에는 하나의 요소의 버퍼만 갖고 있고, 새로운 요소가 보내질 때마다 이전 요소는 유실된다.
또한 송신자가 절대로 일시 중지되지 않는다는 것을 의미한다.

## 채널과 상호작용

Channel<T>의 동작은 SendChannel<T>와 ReceiveChannel<T>의 두 개의 인터페이스로 이뤄져 있다.

### SendChannel

채널을 통해 요소를 보내기 위한 몇개의 함수와 무언가를 보낼 수 있는지 검증하기 위한 다른 함수들을 정의한다.

#### 보내기 전 검증

채널을 통해 요소를 보내기 전에 수행할 수 있는 몇가지 검증 방법이 있다.
가장 일반적인 방법은 전송을 위한 채널이 닫히지 않았는지 확인하는 것이다.
이를 위해서 isClosedForSend를 사용할 수 있다.

#### 요소 전송

채널을 통해 요소를 전송하려면 앞에서 본 바와 같이 send() 함수를 사용해야 한다.
함수는 버퍼드 채널에서 버퍼가 가득 차면 송신자를 일시 중단하며, RendezvousChannel이면 receive()가 호출될 때까지 일시 중단하는 일시 중단 함수다.

#### 채널이 닫힌 상태

channel.isClosedForSend가 true인 경우, offer()는 ClosedSendChannelException 유형의 예외를 던진다.

#### 채널이 가득 찬 상태

isFull이 true이면 offer()는 간단히 false를 반환한다.

#### 채널이 열리고 가득 차지 않은 상태

채널이 열려 있고 가득 차 있지 않을 때는 offer()는 요소를 대기열에 추가한다.
일시 중단 연산에서 발생하지 않은 채널에 요소를 추가하는 유일한 방법이다.

### 읽기 전 유효성 검사

예외를 피하거나 일반적인 코드 흐름 개선을 위해, ReceiveChannel에서 정보를 읽기 전에 몇 가지 확인할 사항이 있다.

#### isClosedForReceive

첫 번째는, 수신에 대해 닫힌 채널인지 여부를 나타내는 isClosedForRecevie 속성을 확인해야 하낟.
닫힌 채널에서 recieve가 호출되면, ClosedReceiveChannelException이 발생한다.

#### isEmpty

두 번째 유효성 확인은 수신할 것이 있는지 여부를 확인하는 일이다.


## 요약
- 협업 동시성과 관련된 과제를 해결하기 위해 채널을 사용하는 몇 가지 실제 사례를 논의했다.
- 채널이 일종의 통신 도구라는 것을 배웠다. 채널은 스레드와 관련없이 코루틴간에 메시지를 안전하게 보낼 수 있다.
- 언버퍼드 채널에 대해 이야기했다. 이러한 채널은 각 요소를 위한 receive()가 호출될 때까지 send()를 일시 중단한다.
- 세 가지 유형의 버퍼드 채널을 다루었다. ConflatedChannel은 전송된 마지막 요소를 유지한다. LinkedListChannel은 무제한 요소를 갖거나, 최소환 가용한 메모리에서 가능한 많은 요소를 가질 수 있어서 send()거 호출되더라도 중단되지 않는다. ArrayChannel은 요소의양이 버퍼 크기에 도달하면 send()에서 일시 중지된다.
- SendChannel의 isClosedForSend와 isFull과 같은 여러 가지 중요한 속성과 함수들을 익혔다. 또한 일시 중단 함수인 send()와 비 일시 중단 함수인 offer()에 대해서도 이야기 했다. 닫힌 송신 채널에서 send 또는 offer를 시도할 때 발생할 수 있는 예외에 대해서 설명했다.
- ReceiveChannel에 대해서도 다뤘으며, isClosedForReceive와 isEmpty 속성의 사용법에 대해서 설명했다. 그 위에서 닫힌 수신 채널로부터 수신하려고 할 때 발생할 수 있는 예외들에 대해서 살펴봤다.
